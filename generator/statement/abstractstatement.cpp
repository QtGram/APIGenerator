#include "abstractstatement.h"
#include "../../global.h"
#include <QRegularExpression>
#include <QStringList>
#include <QDebug>
#include <QDir>

AbstractStatement::AbstractStatement(const QString &name, const QString &destinationdir): _visibility(AbstractStatement::PUBLIC), _name(name), _destinationdir(destinationdir)
{
}

AbstractStatement::~AbstractStatement()
{
}

void AbstractStatement::define(std::function<void(QString &, QString &)> definefunc)
{
    QString definekey, defineval;
    definefunc(definekey, defineval);

    this->_definelist << definekey + " " + defineval;
}

const QString &AbstractStatement::name() const
{
    return this->_name;
}

QByteArray AbstractStatement::apiGeneratorMark() const
{
    return QString("// Generated by APIGenerator %1\n// DO NOT EDIT!!!\n\n").arg(APIGENERATOR_VERSION).toUtf8();
}

QString AbstractStatement::firstAttribute(int attributes) const
{
    QString s;

    if(attributes & AbstractStatement::STATIC)
        s = "static";
    else if(attributes & AbstractStatement::VIRTUAL)
        s = "virtual";

    return s;
}

QString AbstractStatement::lastAttribute(int attributes) const
{
    QString s;

    if(attributes & AbstractStatement::CONST)
        s = "const";
    else if(attributes & AbstractStatement::ABSTRACT)
        s = "= 0";

    return s;
}

QString AbstractStatement::visibilityString(int v) const
{
    if(v == AbstractStatement::PRIVATE)
        return "\tprivate:\n";

    if(v == AbstractStatement::PROTECTED)
        return "\tprotected:\n";

    return "\tpublic:\n";
}

QString AbstractStatement::camelCase(const QString &s, bool firstupper) const
{
    if(s.isEmpty())
        return QString();

    QStringList parts = s.split('_', QString::SkipEmptyParts);

    for (int i = 1; i < parts.size(); i++)
        parts[i].replace(0, 1, parts[i][0].toUpper());

    QString res = parts.join("");

    if(firstupper)
        return res.at(0).toUpper() + res.mid(1);

    return res;
}

void AbstractStatement::doWrite(const QString& ext) const
{
    if(this->_destinationdir.isEmpty())
    {
        qWarning() << "No destination dir set";
        return;
    }

    QDir dir(this->_destinationdir);
    QFile file(dir.absoluteFilePath(this->_name.toLower() + ext));

    if(!file.open(QFile::WriteOnly))
    {
        qWarning() << "Cannot open:" << dir.absoluteFilePath(this->_name.toLower() + ext);
        return;
    }

    if(ext == ".h")
        file.write(QString("#ifndef %1_H\n#define %1_H\n\n").arg(this->_name.toUpper()).toUtf8());

    file.write(this->apiGeneratorMark());

    if(!this->_definelist.isEmpty())
    {
        foreach(QString define, this->_definelist)
        {
            file.write("#define ");
            file.write(define.toUtf8().constData());
            file.write("\n");
        }

        file.write("\n");
    }

    file.write(this->toString().toUtf8());

    if(ext == ".h")
        file.write(QString("\n#endif // %1_H\n").arg(this->_name.toUpper()).toUtf8());

    file.close();
}

int AbstractStatement::indent(QString &s, int indent)
{
    QString strindent = QString("\t").repeated(qMax(1, indent));
    QStringList lines = s.trimmed().split(QRegularExpression("[\\n\\r]"));
    s.clear();

    foreach(QString line, lines)
        s += strindent + line + "\n";

    return lines.length();
}

void AbstractStatement::setVisibility(int v)
{
    this->_visibility = v;
}

int AbstractStatement::visibility() const
{
    return this->_visibility;
}

void AbstractStatement::write() const
{
    this->doWrite(QString());
}
